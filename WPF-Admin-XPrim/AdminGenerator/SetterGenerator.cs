using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace AdminGenerator
{
    public class SetterGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // 添加调试信息 - 生成一个测试文件来确认生成器被调用
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource("DebugInfo.g.cs", "// Debug: SetterGenerator initialized successfully");
            });

            // 简化：只查找带有[Setter]属性的字段
            var fieldDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (node, _) => node is FieldDeclarationSyntax field &&
                                            field.AttributeLists.Count > 0,
                    transform: (ctx, _) => 
                    {
                        var field = ctx.Node as FieldDeclarationSyntax;
                        if (field == null) return null;

                        // 直接检查属性名称
                        var hasSetterAttribute = field.AttributeLists
                            .SelectMany(al => al.Attributes)
                            .Any(attr => attr.Name.ToString().Contains("Setter"));

                        return hasSetterAttribute ? field : null;
                    })
                .Where(field => field != null);

            var compilationAndFields = context.CompilationProvider.Combine(fieldDeclarations.Collect());

            context.RegisterSourceOutput(compilationAndFields, (ctx, source) =>
                Execute(ctx, source.Left, source.Right!));
        }

        private static void Execute(
            SourceProductionContext context,
            Compilation compilation,
            System.Collections.Immutable.ImmutableArray<FieldDeclarationSyntax> fields)
        {
            // 生成一个简单的调试文件来确认生成器被调用
            context.AddSource("Debug_SetterGenerator.g.cs", "// Generated by SetterGenerator - Debug file");
            
            // 记录找到的字段数量
            context.AddSource("FieldCount.g.cs", $"// Found {fields.Length} fields with attributes");
            
            if (fields.Length == 0)
            {
                context.AddSource("NoFields.g.cs", "// No fields found with [Setter] attribute");
                return;
            }

            foreach (var field in fields.Where(f => f != null))
            {
                // 为每个找到的字段生成一个简单的测试文件
                var className = field.FirstAncestorOrSelf<ClassDeclarationSyntax>()?.Identifier.Text ?? "Unknown";
                var fieldName = field.Declaration.Variables.FirstOrDefault()?.Identifier.Text ?? "Unknown";
                
                context.AddSource($"{className}_{fieldName}.g.cs", 
                    $"// Found field: {className}.{fieldName} with [Setter] attribute");

                var model = compilation.GetSemanticModel(field.SyntaxTree);
                // 获取字段符号（FieldDeclaration可能包含多个变量）
                foreach (var variable in field.Declaration.Variables)
                {
                    var fieldSymbol = model.GetDeclaredSymbol(variable) as IFieldSymbol;
                    if (fieldSymbol == null) continue;

                    // 检查字段是否为只读
                    if (fieldSymbol.IsReadOnly)
                    {
                        continue;
                    }

                    // 查找我们的自定义属性 - 使用更精确的匹配逻辑
                    var attribute = fieldSymbol.GetAttributes()
                        .FirstOrDefault(a =>
                            a.AttributeClass?.Name == "SetterAttribute" ||
                            a.AttributeClass?.ToDisplayString().EndsWith("SetterAttribute") == true);

                    if (attribute == null) continue;

                    var classDecl = field.FirstAncestorOrSelf<ClassDeclarationSyntax>();
                    if (classDecl == null) continue;

                    // 检查类是否为partial
                    if (!classDecl.Modifiers.Any(m =>
                            m.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.PartialKeyword)))
                    {
                        continue;
                    }

                    // 检查类是否实现了必要的接口
                    var classSymbol = model.GetDeclaredSymbol(classDecl) as ITypeSymbol;
                    bool implementsChainedGenerate = classSymbol?.AllInterfaces.Any(i =>
                        i.Name == "IChainedGenerate" ||
                        i.ToDisplayString().EndsWith("IChainedGenerate")) == true;

                    // 验证接口实现
                    if (!implementsChainedGenerate)
                    {
                        continue;
                    }

                    // 处理当前变量
                    var propertyName = GetPropertyName(variable, attribute);
                    var source = GeneratePropertySource(
                        field, variable, propertyName, attribute,
                        classDecl, compilation);

                    // 生成唯一的文件名，考虑嵌套类
                    var classNameWithNested = GetFullClassName(classDecl);
                    var classNameSpace = GetFullNamespace(classDecl);
                    context.AddSource(
                        $"{classNameSpace}.{classNameWithNested}_{PropertyName(variable.Identifier.Text)}.g.cs",
                        Microsoft.CodeAnalysis.Text.SourceText.From(source, Encoding.UTF8));
                }
            }
        }

        private static string GetPropertyName(VariableDeclaratorSyntax variable, AttributeData attribute)
        {
            // 安全地获取构造函数参数
            if (attribute.ConstructorArguments.Length > 0 &&
                attribute.ConstructorArguments[0].Value is string name &&
                !string.IsNullOrEmpty(name))
            {
                return name;
            }

            var fieldName = variable.Identifier.Text;

            return PropertyName(fieldName);
        }

        private static string PropertyName(string fieldName)
        {
            // 如果字段名以下划线开头，则移除下划线
            if (fieldName.StartsWith("_"))
            {
                fieldName = fieldName.Substring(1);
            }

            // 确保首字母大写（Pascal Case）
            if (fieldName.Length > 0)
            {
                return char.ToUpper(fieldName[0]) + (fieldName.Length > 1 ? fieldName.Substring(1) : "");
            }

            return fieldName;
        }

        public static string GetFullTypeName(TypeSyntax typeSyntax, SemanticModel semanticModel)
        {
            // 获取类型符号
            var typeInfo = semanticModel.GetTypeInfo(typeSyntax);
            ITypeSymbol? typeSymbol = typeInfo.Type;

            if (typeSymbol == null)
                return string.Empty;

            // 获取完整限定名（包含命名空间）
            string fullName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            // 对于泛型类型，ToDisplayString 会自动包含类型参数
            // 例如："System.Collections.Generic.List<System.String>"

            return fullName;
        }

        private static string GeneratePropertySource(
            FieldDeclarationSyntax field,
            VariableDeclaratorSyntax variable,
            string propertyName,
            AttributeData attribute,
            ClassDeclarationSyntax classDecl,
            Compilation compilation)
        {
            var fieldName = variable.Identifier.Text;
            var semanticModel = compilation.GetSemanticModel(field.SyntaxTree);
            string typeName = GetFullTypeName(field.Declaration.Type, semanticModel);

            // 安全地获取命名参数，提供默认值
            var includeSetter = GetNamedArgumentValue(attribute, "IncludeSetter", true);

            var source = new StringBuilder();
            source.AppendLine("// <auto-generated/>");
            source.AppendLine("using System.ComponentModel;");
            source.AppendLine();

            // 处理命名空间
            var namespaceDecl = field.FirstAncestorOrSelf<BaseNamespaceDeclarationSyntax>();
            if (namespaceDecl != null)
            {
                source.AppendLine($"namespace {namespaceDecl.Name};");
                source.AppendLine();
            }

            // 处理嵌套类
            var classHierarchy = new List<ClassDeclarationSyntax>();
            var currentClass = classDecl;
            while (currentClass != null)
            {
                classHierarchy.Insert(0, currentClass);
                currentClass = currentClass.Parent as ClassDeclarationSyntax;
            }

            foreach (var cls in classHierarchy.Take(classHierarchy.Count - 1))
            {
                source.AppendLine($"partial class {cls.Identifier.Text}");
                source.AppendLine("{");
            }

            source.AppendLine($"public partial class {classHierarchy.Last().Identifier.Text}");
            source.AppendLine("{");
            source.AppendLine($"   public {classHierarchy.Last().Identifier.Text} set{propertyName}({typeName} value)");
            source.AppendLine("    {");
            source.AppendLine($"        {fieldName} = value;");
            source.AppendLine($"        return this;");
            source.AppendLine("    }");
            source.AppendLine("}");
            // 关闭嵌套类的括号
            foreach (var _ in classHierarchy.Take(classHierarchy.Count - 1))
            {
                source.AppendLine("}");
            }

            return source.ToString();
        }

        private static bool GetNamedArgumentValue(AttributeData attribute, string argumentName, bool defaultValue)
        {
            var namedArg = attribute.NamedArguments.FirstOrDefault(kvp => kvp.Key == argumentName);
            if (namedArg.Key == argumentName && namedArg.Value.Value is bool value)
            {
                return value;
            }
            
            if (argumentName == "IncludeOnChangedMethod")
            {
                return true; // 确保与属性定义一致
            }

            return defaultValue;
        }

        // 获取完整的类名（包括嵌套类）
        private static string GetFullClassName(ClassDeclarationSyntax classDecl)
        {
            var names = new List<string>();
            var current = classDecl;

            while (current != null)
            {
                names.Insert(0, current.Identifier.Text);
                current = current.Parent as ClassDeclarationSyntax;
            }

            return string.Join("_", names);
        }

        private static string GetFullNamespace(ClassDeclarationSyntax classDecl)
        {
            // 存储命名空间片段
            var nsParts = new List<string>();

            // 从类的父节点开始向上查找
            var current = classDecl.Parent;

            while (current != null)
            {
                // 处理常规命名空间声明
                if (current is NamespaceDeclarationSyntax namespaceDecl)
                {
                    // 命名空间可能包含多个部分（如 A.B.C）
                    var nameParts = GetNameParts(namespaceDecl.Name);
                    nsParts.InsertRange(0, nameParts);
                    break; // 命名空间声明的父级不会再有其他命名空间
                }
                // 处理文件级命名空间
                else if (current is FileScopedNamespaceDeclarationSyntax fileNsDecl)
                {
                    var nameParts = GetNameParts(fileNsDecl.Name);
                    nsParts.InsertRange(0, nameParts);
                    break;
                }

                current = current.Parent;
            }

            return string.Join(".", nsParts);
        }

        private static IEnumerable<string> GetNameParts(NameSyntax name)
        {
            if (name is IdentifierNameSyntax identifier)
            {
                yield return identifier.Identifier.Text;
            }
            else if (name is QualifiedNameSyntax qualified)
            {
                // 递归获取左侧部分
                foreach (var part in GetNameParts(qualified.Left))
                {
                    yield return part;
                }

                // 添加右侧部分
                yield return qualified.Right.Identifier.Text;
            }
        }
    }
}